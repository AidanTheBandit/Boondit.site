---
import Layout from "@/layouts/Layout.astro";
import Section from "@/components/Section.astro";
import FlashStatus from "@/components/flash/FlashStatus.astro";
import FlashProgress from "@/components/flash/FlashProgress.astro";
import FlashLog from "@/components/flash/FlashLog.astro";
---

<Layout title="R1 Flash Utility - Boondit">
  <Section title="R1 Flash Utility" className="min-h-screen">
    <div class="max-w-6xl mx-auto p-6 space-y-8">
      <header class="text-center space-y-3">
        <p class="text-gray-400 text-lg">
          Flash the latest Rabbit R1 stock firmware directly from your browser.
        </p>
        <div class="bg-red-500/10 border border-red-500/30 rounded-xl p-4 max-w-3xl mx-auto">
          <p class="text-red-200 text-sm">
            Warning: Flashing firmware can erase data or brick your device if
            interrupted. Wipe is always enabled. Proceed only if you accept the risk.
          </p>
        </div>
      </header>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Main Controls -->
        <div class="lg:col-span-2 space-y-6">
          
          <!-- Auto Flash Mode -->
          <article class="card bg-gradient-auto">
            <h2 class="card-title">Auto Flash</h2>
            <p class="text-gray-300 text-sm mb-4">
              Automated workflow: Powers on device via BROM, downloads latest firmware, and flashes automatically.
            </p>
            <button id="autoFlash" class="btn-auto w-full">
              Start Auto Flash
            </button>
          </article>

          <div class="divider">Manual Mode</div>

          <!-- Manual Controls -->
          <details class="card" open>
            <summary class="card-title cursor-pointer">Manual Flash Steps</summary>
            <div class="space-y-4 mt-4">
              
              <div>
                <h3 class="text-sm font-semibold text-gray-300 mb-2">Step 0: Enter Fastboot (BROM)</h3>
                <p class="text-xs text-gray-400 mb-2">
                  If device is powered off, send FASTBOOT command via BROM (Web Serial).
                </p>
                <button id="enterFastboot" class="btn-secondary w-full">
                  Enter Fastboot Mode
                </button>
              </div>

              <div>
                <h3 class="text-sm font-semibold text-gray-300 mb-2">Step 1: Connect Bootloader</h3>
                <p class="text-xs text-gray-400 mb-2">
                  Put device in bootloader fastboot mode and select it.
                </p>
                <button id="connectBootloader" class="btn-primary w-full">
                  Select Device (Bootloader)
                </button>
              </div>

              <div>
                <h3 class="text-sm font-semibold text-gray-300 mb-2">Step 2: Switch to Fastbootd</h3>
                <p class="text-xs text-gray-400 mb-2">
                  Reboot device into fastbootd mode.
                </p>
                <button id="rebootFastbootd" class="btn-secondary w-full" disabled>
                  Reboot to Fastbootd
                </button>
              </div>

              <div>
                <h3 class="text-sm font-semibold text-gray-300 mb-2">Step 3: Connect Fastbootd</h3>
                <p class="text-xs text-gray-400 mb-2">
                  Select device again once in fastbootd mode.
                </p>
                <button id="connectFastbootd" class="btn-primary w-full" disabled>
                  Select Device (Fastbootd)
                </button>
              </div>

              <div>
                <h3 class="text-sm font-semibold text-gray-300 mb-2">Step 4: Flash Firmware</h3>
                <p class="text-xs text-gray-400 mb-2">
                  Download and flash latest firmware. Wipe is always enabled.
                </p>
                <button id="flashStock" class="btn-accent w-full" disabled>
                  Flash Stock OS
                </button>
              </div>

            </div>
          </details>

          <!-- MTK Bootloader Unlock -->
          <details class="card">
            <summary class="card-title cursor-pointer">MTK Bootloader Unlock (Experimental)</summary>
            <div class="space-y-3 mt-4">
              <p class="text-xs text-gray-400">
                Web Serial implementation of MTKClient for unlocking MediaTek bootloaders.
                Currently supports MT6765 and related chipsets via BROM exploitation.
              </p>
              <div class="bg-yellow-500/10 border border-yellow-500/20 rounded-lg p-3">
                <p class="text-yellow-200 text-xs">
                  Experimental: Requires BROM exploit payloads. May brick device if interrupted.
                </p>
              </div>
              <button id="mtkUnlock" class="btn-secondary w-full" disabled>
                Unlock Bootloader (MTK)
              </button>
            </div>
          </details>

        </div>

        <!-- Sidebar: Status, Progress, Log -->
        <aside class="space-y-6">
          <FlashStatus />
          <FlashProgress />
          <FlashLog />
        </aside>
      </div>
    </div>

    <!-- Auto-Flash Modal -->
    <div id="autoFlashModal" class="modal hidden">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <div class="modal-header">
          <h2 id="modalStepTitle" class="text-xl font-bold text-white">Auto Flash Mode</h2>
          <div class="text-sm text-gray-400">Step <span id="modalCurrentStep">1</span> of <span id="modalTotalSteps">4</span></div>
        </div>
        <div class="modal-body">
          <p id="modalInstruction" class="text-gray-300 mb-4">Preparing auto-flash...</p>
          <div id="modalProgress" class="hidden">
            <div class="progress-track mb-2">
              <div id="modalProgressBar" class="progress-bar"></div>
            </div>
            <p id="modalProgressText" class="text-xs text-gray-400 text-center">0%</p>
          </div>
        </div>
        <div class="modal-footer">
          <button id="modalContinue" class="btn-primary">Continue</button>
          <button id="modalCancel" class="btn-secondary">Cancel</button>
        </div>
      </div>
    </div>
  </Section>
</Layout>

<script type="module">
  import { FastbootDevice, USER_ACTION_MAP, setDebugLevel } from "https://cdn.jsdelivr.net/npm/android-fastboot@1.1.3/dist/fastboot.mjs";

  // Inline the essential logic here - import utilities from our library
  // (Library files are for organization, actual logic needs to be browser-compatible)

  const bootloaderDevice = new FastbootDevice();
  const fastbootdDevice = new FastbootDevice();

  const state = {
    bootloaderConnected: false,
    fastbootdConnected: false,
    busy: false,
  };

  const elements = {
    autoFlash: document.getElementById("autoFlash"),
    enterFastboot: document.getElementById("enterFastboot"),
    connectBootloader: document.getElementById("connectBootloader"),
    rebootFastbootd: document.getElementById("rebootFastbootd"),
    connectFastbootd: document.getElementById("connectFastbootd"),
    flashStock: document.getElementById("flashStock"),
    mtkUnlock: document.getElementById("mtkUnlock"),
    webusbStatus: document.getElementById("webusbStatus"),
    webserialStatus: document.getElementById("webserialStatus"),
    bootloaderStatus: document.getElementById("bootloaderStatus"),
    fastbootdStatus: document.getElementById("fastbootdStatus"),
    statusLog: document.getElementById("statusLog"),
    downloadBar: document.getElementById("downloadBar"),
    downloadPct: document.getElementById("downloadPct"),
    flashBar: document.getElementById("flashBar"),
    flashPct: document.getElementById("flashPct"),
    flashAction: document.getElementById("flashAction"),
    flashItem: document.getElementById("flashItem"),
    autoFlashModal: document.getElementById("autoFlashModal"),
    modalStepTitle: document.getElementById("modalStepTitle"),
    modalCurrentStep: document.getElementById("modalCurrentStep"),
    modalTotalSteps: document.getElementById("modalTotalSteps"),
    modalInstruction: document.getElementById("modalInstruction"),
    modalProgress: document.getElementById("modalProgress"),
    modalProgressBar: document.getElementById("modalProgressBar"),
    modalProgressText: document.getElementById("modalProgressText"),
    modalContinue: document.getElementById("modalContinue"),
    modalCancel: document.getElementById("modalCancel"),
  };

  setDebugLevel(1);

  const supportsWebUsb = "usb" in navigator;
  const supportsWebSerial = "serial" in navigator;

  elements.webusbStatus.textContent = supportsWebUsb ? "Supported" : "Unavailable";
  elements.webusbStatus.classList.toggle("is-ok", supportsWebUsb);
  elements.webusbStatus.classList.toggle("is-error", !supportsWebUsb);

  elements.webserialStatus.textContent = supportsWebSerial ? "Supported" : "Unavailable";
  elements.webserialStatus.classList.toggle("is-ok", supportsWebSerial);
  elements.webserialStatus.classList.toggle("is-error", !supportsWebSerial);

  function logStatus(message, type = "info") {
    if (!elements.statusLog) return;
    const entry = document.createElement("div");
    entry.className = `log-entry log-${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    elements.statusLog.appendChild(entry);
    elements.statusLog.scrollTop = elements.statusLog.scrollHeight;
  }

  function setProgress(bar, label, value) {
    if (!bar || !label) return;
    const pct = Math.round(value * 100);
    bar.style.width = `${pct}%`;
    label.textContent = `${pct}%`;
  }

  function setConnectionStatus() {
    elements.bootloaderStatus.textContent = state.bootloaderConnected
      ? "Connected"
      : "Not connected";
    elements.bootloaderStatus.classList.toggle("is-ok", state.bootloaderConnected);
    elements.bootloaderStatus.classList.toggle("is-error", !state.bootloaderConnected);

    elements.fastbootdStatus.textContent = state.fastbootdConnected
      ? "Connected"
      : "Not connected";
    elements.fastbootdStatus.classList.toggle("is-ok", state.fastbootdConnected);
    elements.fastbootdStatus.classList.toggle("is-error", !state.fastbootdConnected);
  }

  function setButtonStates() {
    const { bootloaderConnected, fastbootdConnected, busy } = state;
    elements.autoFlash.disabled = busy;
    elements.enterFastboot.disabled = busy;
    elements.connectBootloader.disabled = busy;
    elements.rebootFastbootd.disabled = busy || !bootloaderConnected;
    elements.connectFastbootd.disabled = busy;
    elements.flashStock.disabled = busy || !fastbootdConnected;
    elements.mtkUnlock.disabled = true;
  }

  const FIRMWARE_MIRROR_BASE = 
    (window.location.hostname.includes("github.dev") ||
     window.location.hostname.includes("githubpreview.dev") ||
     window.location.hostname.includes("localhost"))
      ? "/firmware"
      : "https://boondit.site/firmware";

  async function fetchLatestFirmware() {
    const response = await fetch("https://api.github.com/repos/rabbit-hmi-oss/firmware/releases/latest");
    if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
    
    const data = await response.json();
    const asset = (data.assets || []).find((entry) =>
      entry.name && entry.name.toLowerCase().endsWith(".zip")
    );
    
    if (!asset) throw new Error("No firmware zip asset found.");
    
    return {
      name: asset.name,
      apiUrl: asset.url,
      url: asset.browser_download_url,
      mirrorUrl: FIRMWARE_MIRROR_BASE ? `${FIRMWARE_MIRROR_BASE}/${asset.name}` : null,
    };
  }

  async function downloadFirmware(asset, onProgress) {
    const candidateUrls = [
      { label: "Mirror", url: asset.mirrorUrl },
      { label: "GitHub API", url: asset.apiUrl, headers: { Accept: "application/octet-stream" } },
      { label: "Direct", url: asset.url },
    ].filter(c => c.url);

    let response;
    for (const candidate of candidateUrls) {
      try {
        response = await fetch(candidate.url, {
          headers: candidate.headers || {},
          redirect: "follow",
          cache: "no-store",
        });
        if (response.ok) break;
      } catch (error) {
        response = undefined;
      }
    }

    if (!response || !response.ok) {
      throw new Error("Firmware download failed from all sources.");
    }

    const contentLength = Number(response.headers.get("content-length") || 0);
    
    if (!response.body || !response.body.getReader) {
      const blob = await response.blob();
      return new File([blob], asset.name, { type: "application/zip" });
    }

    const reader = response.body.getReader();
    const chunks = [];
    let received = 0;
    const startTime = Date.now();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      if (value) {
        chunks.push(value);
        received += value.length;
        
        if (onProgress && contentLength) {
          const elapsed = (Date.now() - startTime) / 1000;
          const speed = received / elapsed;
          const remaining = contentLength - received;
          const eta = remaining / speed;
          
          onProgress({
            loaded: received,
            total: contentLength,
            percentage: received / contentLength,
            speed,
            eta,
          });
        }
      }
    }

    const blob = new Blob(chunks, { type: "application/zip" });
    return new File([blob], asset.name, { type: "application/zip" });
  }

  async function enterFastbootFromBrom() {
    state.busy = true;
    setButtonStates();
    logStatus("Requesting BROM device...");
    
    try {
      const port = await navigator.serial.requestPort({
        filters: [{ usbVendorId: 0x0e8d, usbProductId: 0x2000 }],
      });

      await port.open({ baudRate: 115200 });
      const writer = port.writable.getWriter();
      
      const encoder = new TextEncoder();
      const command = encoder.encode("FASTBOOT");
       
      await writer.write(command);
      await writer.close();
      await port.close();
      
      logStatus("BROM fastboot command sent.", "success");
    } catch (error) {
      logStatus(`BROM fastboot failed: ${error.message || error}`, "error");
    } finally {
      state.busy = false;
      setButtonStates();
    }
  }

  async function connectBootloader() {
    state.busy = true;
    setButtonStates();
    logStatus("Requesting bootloader device...");
    
    try {
      await bootloaderDevice.connect();
      state.bootloaderConnected = true;
      logStatus("Bootloader device connected.", "success");
    } catch (error) {
      logStatus(`Bootloader connection failed: ${error.message || error}`, "error");
    } finally {
      state.busy = false;
      setButtonStates();
      setConnectionStatus();
    }
  }

  async function rebootToFastbootd() {
    state.busy = true;
    setButtonStates();
    logStatus("Rebooting device into fastbootd...");
    
    try {
      await bootloaderDevice.runCommand("reboot-fastboot");
      state.bootloaderConnected = false;
      logStatus("Device rebooted. Select it again in fastbootd.", "success");
    } catch (error) {
      logStatus(`Reboot failed: ${error.message || error}`, "error");
    } finally {
      state.busy = false;
      setButtonStates();
      setConnectionStatus();
    }
  }

  async function connectFastbootd() {
    state.busy = true;
    setButtonStates();
    logStatus("Requesting fastbootd device...");
    
    try {
      await fastbootdDevice.connect();
      state.fastbootdConnected = true;
      logStatus("Fastbootd device connected.", "success");
    } catch (error) {
      logStatus(`Fastbootd connection failed: ${error.message || error}`, "error");
    } finally {
      state.busy = false;
      setButtonStates();
      setConnectionStatus();
    }
  }

  async function flashStockOs() {
    state.busy = true;
    setButtonStates();
    setProgress(elements.flashBar, elements.flashPct, 0);
    setProgress(elements.downloadBar, elements.downloadPct, 0);
    elements.flashAction.textContent = "Preparing";
    elements.flashItem.textContent = "Finding latest firmware";

    try {
      const asset = await fetchLatestFirmware();
      logStatus(`Latest firmware found: ${asset.name}`);
      elements.flashAction.textContent = "Downloading";
      elements.flashItem.textContent = asset.name;

      const firmwareFile = await downloadFirmware(asset, (progress) => {
        setProgress(elements.downloadBar, elements.downloadPct, progress.percentage);
        const sizeMB = (progress.loaded / 1024 / 1024).toFixed(1);
        const totalMB = (progress.total / 1024 / 1024).toFixed(1);
        const speedMBps = (progress.speed / 1024 / 1024).toFixed(2);
        const etaMin = Math.ceil(progress.eta / 60);
        elements.flashItem.textContent = `${sizeMB}/${totalMB} MB @ ${speedMBps} MB/s (~${etaMin}m)`;
      });

      logStatus(`Firmware downloaded: ${(firmwareFile.size / 1024 / 1024).toFixed(1)} MB`);
      elements.flashAction.textContent = "Flashing";
      elements.flashItem.textContent = "Preparing flash...";

      // Reconnect callback with delay to avoid race conditions
      const reconnectCallback = async () => {
        logStatus("Device reconnecting - waiting for stability...", "info");
        await new Promise(resolve => setTimeout(resolve, 2500));
      };

      await fastbootdDevice.flashFactoryZip(
        firmwareFile,
        true,
        reconnectCallback,
        (action, item, progress) => {
          const actionLabel = USER_ACTION_MAP[action] || action || "Working";
          elements.flashAction.textContent = actionLabel;
          elements.flashItem.textContent = item ? `Target: ${item}` : "Working";
          setProgress(elements.flashBar, elements.flashPct, progress || 0);
        }
      );

      logStatus("Flash completed successfully!", "success");
      elements.flashAction.textContent = "Completed";
      elements.flashItem.textContent = "Device flashed";
      setProgress(elements.flashBar, elements.flashPct, 1);
    } catch (error) {
      // Check for device state race condition
      if (error.message && error.message.includes("operation that changes the device state is in progress")) {
        logStatus("Device reconnection race condition detected. Please wait a moment and try flashing again.", "error");
        logStatus("Tip: Give the device 5-10 seconds to stabilize after connecting to fastbootd before flashing.", "info");
      } else {
        logStatus(`Flash failed: ${error.message || error}`, "error");
      }
      if (error.stack) console.error("Stack trace:", error.stack);
      elements.flashAction.textContent = "Error";
      elements.flashItem.textContent = "Flash failed";
    } finally {
      state.busy = false;
      setButtonStates();
    }
  }

  function showModal(step, title, instruction, showProgress = false) {
    elements.modalCurrentStep.textContent = step;
    elements.modalTotalSteps.textContent = "4";
    elements.modalStepTitle.textContent = title;
    elements.modalInstruction.textContent = instruction;
    elements.modalProgress.classList.toggle("hidden", !showProgress);
    elements.autoFlashModal.classList.remove("hidden");
  }

  function hideModal() {
    elements.autoFlashModal.classList.add("hidden");
  }

  function waitForUserClick() {
    return new Promise((resolve, reject) => {
      elements.modalContinue.onclick = () => {
        elements.modalContinue.onclick = null;
        elements.modalCancel.onclick = null;
        resolve();
      };
      elements.modalCancel.onclick = () => {
        elements.modalContinue.onclick = null;
        elements.modalCancel.onclick = null;
        reject(new Error("User cancelled"));
      };
    });
  }

  async function autoFlash() {
    state.busy = true;
    setButtonStates();
    logStatus("Starting auto flash sequence...", "info");

    try {
      // Step 1: BROM (optional)
      showModal(1, "Enter Fastboot via BROM", "Connect your powered-off device. Click Continue to select the BROM serial port and send the FASTBOOT command.");
      await waitForUserClick();
      logStatus("Step 1: Entering fastboot mode from BROM...", "info");
      try {
        await enterFastbootFromBrom();
        await new Promise(resolve => setTimeout(resolve, 1500));
        logStatus("BROM fastboot command sent.", "success");
      } catch (error) {
        logStatus("BROM step skipped (device may already be in fastboot)", "info");
      }

      // Step 2: Connect bootloader
      showModal(2, "Connect Bootloader", "Device should now be in fastboot bootloader mode. Click Continue to select the USB device.");
      await waitForUserClick();
      logStatus("Step 2: Connecting to bootloader...", "info");
      await connectBootloader();
      if (!state.bootloaderConnected) {
        throw new Error("Failed to connect to bootloader");
      }

      // Step 3: Reboot to fastbootd
      showModal(3, "Reboot to Fastbootd", "Rebooting device to fastbootd mode. The device will disconnect and reconnect. Click Continue when ready to select it again.");
      logStatus("Step 3: Rebooting to fastbootd...", "info");
      await rebootToFastbootd();
      await new Promise(resolve => setTimeout(resolve, 2000));
      await waitForUserClick();
      logStatus("Step 3: Connecting to fastbootd...", "info");
      await connectFastbootd();
      if (!state.fastbootdConnected) {
        throw new Error("Failed to connect to fastbootd");
      }
      
      // Give device time to stabilize before flash
      logStatus("Device connected. Waiting for stability...", "info");
      await new Promise(resolve => setTimeout(resolve, 3000));

      // Step 4: Flash firmware
      showModal(4, "Flash Firmware", "Downloading and flashing latest firmware. This may take 10-15 minutes. Do not disconnect the device.", true);
      logStatus("Step 4: Flashing firmware...", "info");
      await flashStockOs();

      hideModal();
      logStatus("Auto flash sequence completed successfully!", "success");
    } catch (error) {
      hideModal();
      logStatus(`Auto flash failed: ${error.message || error}`, "error");
    } finally {
      state.busy = false;
      setButtonStates();
    }
  }

  elements.autoFlash.addEventListener("click", autoFlash);
  elements.enterFastboot.addEventListener("click", enterFastbootFromBrom);
  elements.connectBootloader.addEventListener("click", connectBootloader);
  elements.rebootFastbootd.addEventListener("click", rebootToFastbootd);
  elements.connectFastbootd.addEventListener("click", connectFastbootd);
  elements.flashStock.addEventListener("click", flashStockOs);
  elements.mtkUnlock.addEventListener("click", () => {
    logStatus("MTK bootloader unlock is experimental and not yet implemented.", "error");
  });

  setButtonStates();
  setConnectionStatus();
  logStatus("R1 Flash Utility ready.");
</script>

<style>
  .card {
    background: rgba(31, 41, 55, 0.6);
    backdrop-filter: blur(8px);
    border-radius: 1rem;
    padding: 2rem;
    border: 1px solid rgba(75, 85, 99, 0.5);
    transition: transform 0.2s;
  }

  .card.bg-gradient-auto {
    background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%);
    border: 1px solid rgba(168, 85, 247, 0.3);
  }

  .card-title {
    font-size: 1.25rem;
    font-weight: 700;
    color: #fff;
    margin-bottom: 0.75rem;
    padding-bottom: 0.75rem;
    border-bottom: 2px solid rgba(168, 85, 247, 0.3);
  }

  details[open] .card-title::after {
    content: " ▼";
    font-size: 0.75rem;
  }

  details:not([open]) .card-title::after {
    content: " ▶";
    font-size: 0.75rem;
  }

  .divider {
    text-align: center;
    color: #64748b;
    font-size: 0.875rem;
    font-weight: 500;
    margin: 1.5rem 0;
    position: relative;
  }

  .divider::before,
  .divider::after {
    content: "";
    position: absolute;
    top: 50%;
    width: 45%;
    height: 1px;
    background: rgba(148, 163, 184, 0.3);
  }

  .divider::before {
    left: 0;
  }

  .divider::after {
    right: 0;
  }

  .btn-primary,
  .btn-secondary,
  .btn-accent,
  .btn-auto {
    font-weight: 600;
    border-radius: 0.5rem;
    padding: 0.875rem 1.5rem;
    font-size: 1rem;
    transition: all 0.2s;
    border: none;
    cursor: pointer;
  }

  .btn-primary {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: #fff;
  }

  .btn-secondary {
    background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
    color: #fff;
  }

  .btn-accent {
    background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);
    color: #fff;
  }

  .btn-auto {
    background: linear-gradient(135deg, #ec4899 0%, #a855f7 100%);
    color: #fff;
    font-size: 1.125rem;
    padding: 1.125rem 2rem;
  }

  .btn-primary:hover,
  .btn-secondary:hover,
  .btn-accent:hover,
  .btn-auto:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  .btn-primary:disabled,
  .btn-secondary:disabled,
  .btn-accent:disabled,
  .btn-auto:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  /* Modal Styles */
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .modal.hidden {
    display: none;
  }

  .modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.75);
    backdrop-filter: blur(4px);
  }

  .modal-content {
    position: relative;
    background: linear-gradient(135deg, rgba(31, 41, 55, 0.95) 0%, rgba(17, 24, 39, 0.95) 100%);
    border: 1px solid rgba(168, 85, 247, 0.3);
    border-radius: 1rem;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
  }

  .modal-header {
    margin-bottom: 1.5rem;
    text-align: center;
    border-bottom: 1px solid rgba(168, 85, 247, 0.2);
    padding-bottom: 1rem;
  }

  .modal-body {
    margin-bottom: 1.5rem;
    min-height: 100px;
  }

  .modal-footer {
    display: flex;
    gap: 1rem;
    justify-content: center;
  }

  .modal-footer button {
    flex: 1;
    max-width: 200px;
  }
</style>
